//! Trading signals generated by strategies.

use crate::state::{OrderSide, OrderType};
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::fmt;
use uuid::Uuid;

/// A trading signal generated by a strategy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Unique signal identifier.
    pub id: String,
    /// Strategy that generated this signal.
    pub strategy_name: String,
    /// Type of signal.
    pub signal_type: SignalType,
    /// Signal strength/confidence.
    pub strength: SignalStrength,
    /// Market condition ID.
    pub market_id: String,
    /// Token ID to trade.
    pub token_id: String,
    /// Suggested order side.
    pub side: OrderSide,
    /// Order type (limit or market).
    pub order_type: OrderType,
    /// Target price (limit price). Required for limit orders, optional for market orders.
    pub price: Option<Decimal>,
    /// Suggested size.
    pub size: Decimal,
    /// Time-to-live in seconds (signal expires after this).
    pub ttl_secs: u64,
    /// When the signal was generated.
    pub created_at: DateTime<Utc>,
    /// Optional reason/rationale for the signal.
    pub reason: Option<String>,
    /// Additional metadata.
    pub metadata: SignalMetadata,
}

impl Signal {
    /// Create a new buy signal.
    pub fn buy(market_id: impl Into<String>, token_id: impl Into<String>, size: Decimal) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            strategy_name: String::new(),
            signal_type: SignalType::Entry,
            strength: SignalStrength::Medium,
            market_id: market_id.into(),
            token_id: token_id.into(),
            side: OrderSide::Buy,
            order_type: OrderType::Limit,
            price: None,
            size,
            ttl_secs: 60,
            created_at: Utc::now(),
            reason: None,
            metadata: SignalMetadata::default(),
        }
    }

    /// Create a new sell signal.
    pub fn sell(market_id: impl Into<String>, token_id: impl Into<String>, size: Decimal) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            strategy_name: String::new(),
            signal_type: SignalType::Exit,
            strength: SignalStrength::Medium,
            market_id: market_id.into(),
            token_id: token_id.into(),
            side: OrderSide::Sell,
            order_type: OrderType::Limit,
            price: None,
            size,
            ttl_secs: 60,
            created_at: Utc::now(),
            reason: None,
            metadata: SignalMetadata::default(),
        }
    }

    /// Set the strategy name.
    pub fn with_strategy(mut self, name: impl Into<String>) -> Self {
        self.strategy_name = name.into();
        self
    }

    /// Set the signal type.
    pub fn with_type(mut self, signal_type: SignalType) -> Self {
        self.signal_type = signal_type;
        self
    }

    /// Set the signal strength.
    pub fn with_strength(mut self, strength: SignalStrength) -> Self {
        self.strength = strength;
        self
    }

    /// Set the order type (limit or market).
    pub fn with_order_type(mut self, order_type: OrderType) -> Self {
        self.order_type = order_type;
        self
    }

    /// Set the limit price.
    pub fn with_price(mut self, price: Decimal) -> Self {
        self.price = Some(price);
        self
    }

    /// Set the time-to-live.
    pub fn with_ttl(mut self, ttl_secs: u64) -> Self {
        self.ttl_secs = ttl_secs;
        self
    }

    /// Set the reason/rationale.
    pub fn with_reason(mut self, reason: impl Into<String>) -> Self {
        self.reason = Some(reason.into());
        self
    }

    /// Set stop loss price.
    pub fn with_stop_loss(mut self, price: Decimal) -> Self {
        self.metadata.stop_loss = Some(price);
        self
    }

    /// Set take profit price.
    pub fn with_take_profit(mut self, price: Decimal) -> Self {
        self.metadata.take_profit = Some(price);
        self
    }

    /// Check if the signal has expired.
    pub fn is_expired(&self) -> bool {
        let elapsed = Utc::now()
            .signed_duration_since(self.created_at)
            .num_seconds();
        elapsed > self.ttl_secs as i64
    }

    /// Get the expected value of this signal.
    pub fn expected_value(&self) -> Option<Decimal> {
        self.metadata.expected_value
    }
}

impl fmt::Display for Signal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[{}] {:?} {:?} {} @ {:?} ({})",
            self.strategy_name, self.side, self.signal_type, self.size, self.price, self.strength
        )
    }
}

/// Type of trading signal.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalType {
    /// Enter a new position.
    Entry,
    /// Exit an existing position.
    Exit,
    /// Add to an existing position.
    AddToPosition,
    /// Reduce an existing position.
    ReducePosition,
    /// Rebalance position.
    Rebalance,
    /// Take profit.
    TakeProfit,
    /// Stop loss.
    StopLoss,
}

/// Strength/confidence of a signal.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum SignalStrength {
    /// Low confidence signal.
    Weak,
    /// Medium confidence signal.
    Medium,
    /// High confidence signal.
    Strong,
    /// Very high confidence signal.
    VeryStrong,
}

impl SignalStrength {
    /// Convert to a numeric multiplier (0.0 - 1.0).
    pub fn as_multiplier(&self) -> f64 {
        match self {
            Self::Weak => 0.25,
            Self::Medium => 0.5,
            Self::Strong => 0.75,
            Self::VeryStrong => 1.0,
        }
    }
}

impl fmt::Display for SignalStrength {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Weak => write!(f, "âšª Weak"),
            Self::Medium => write!(f, "ðŸŸ¡ Medium"),
            Self::Strong => write!(f, "ðŸŸ¢ Strong"),
            Self::VeryStrong => write!(f, "ðŸ”µ Very Strong"),
        }
    }
}

/// Additional signal metadata.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SignalMetadata {
    /// Suggested stop loss price.
    pub stop_loss: Option<Decimal>,
    /// Suggested take profit price.
    pub take_profit: Option<Decimal>,
    /// Expected value calculation.
    pub expected_value: Option<Decimal>,
    /// Risk/reward ratio.
    pub risk_reward_ratio: Option<f64>,
    /// Confidence score (0.0 - 1.0).
    pub confidence: Option<f64>,
    /// Indicator values that triggered this signal.
    pub indicators: std::collections::HashMap<String, f64>,
    /// Custom tags.
    pub tags: Vec<String>,
}
