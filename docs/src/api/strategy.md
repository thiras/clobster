# Strategy Module

The strategy module provides the framework for building and executing trading strategies.

## Core Exports

```rust
pub use context::{MarketSnapshot, OrderSnapshot, PositionSnapshot, StrategyContext};
pub use engine::{StrategyEngine, StrategyHandle, StrategyStatus};
pub use risk::{RiskConfig, RiskGuard, RiskViolation};
pub use signal::{Signal, SignalStrength, SignalType};
pub use strategies::{MeanReversionStrategy, MomentumStrategy, SpreadStrategy};
pub use traits::{
    ParameterDef, ParameterType, ParameterValue, Strategy, StrategyConfig, StrategyMetadata,
};
```

## Strategy Trait

The core trait all strategies must implement:

```rust
#[async_trait]
pub trait Strategy: Send + Sync + Debug {
    /// Returns the unique name/identifier of this strategy
    fn name(&self) -> &str;

    /// Returns metadata about this strategy
    fn metadata(&self) -> StrategyMetadata;

    /// Initialize the strategy with configuration
    async fn initialize(&mut self, config: &StrategyConfig) -> Result<()>;

    /// Evaluate the strategy against current market conditions
    fn evaluate(&mut self, ctx: &StrategyContext) -> Vec<Signal>;

    /// Called when a signal from this strategy was executed
    fn on_signal_executed(&mut self, signal: &Signal, success: bool);

    /// Called when market data is updated
    fn on_market_update(&mut self, ctx: &StrategyContext);

    /// Called when an order from this strategy is filled
    fn on_order_filled(&mut self, order_id: &str, price: Decimal, size: Decimal);

    /// Called when an order from this strategy is cancelled
    fn on_order_cancelled(&mut self, order_id: &str);

    /// Clean up any resources when the strategy is stopped
    async fn shutdown(&mut self) -> Result<()>;

    /// Returns the current state for persistence/debugging
    fn state(&self) -> Option<Box<dyn Any + Send + Sync>>;

    /// Restore state from a previous session
    fn restore_state(&mut self, state: Box<dyn Any + Send + Sync>) -> Result<()>;

    /// Validate that the strategy is properly configured
    fn validate(&self) -> Result<()>;

    /// Returns parameters that can be tuned
    fn parameters(&self) -> HashMap<String, ParameterDef>;

    /// Update a parameter value
    fn set_parameter(&mut self, name: &str, value: ParameterValue) -> Result<()>;
}
```

## StrategyContext

Market snapshot provided to strategies:

```rust
pub struct StrategyContext {
    /// Current timestamp
    pub timestamp: DateTime<Utc>,
    /// Available balance for trading
    pub available_balance: Decimal,
}

impl StrategyContext {
    /// Get all market snapshots
    pub fn markets(&self) -> &[MarketSnapshot];
    
    /// Get current positions
    pub fn positions(&self) -> &[PositionSnapshot];
    
    /// Get open orders
    pub fn orders(&self) -> &[OrderSnapshot];
    
    /// Get a specific market by ID
    pub fn get_market(&self, id: &str) -> Option<&MarketSnapshot>;
    
    /// Get position for a specific market/token
    pub fn get_position(&self, market_id: &str, token_id: &str) -> Option<&PositionSnapshot>;
}
```

### MarketSnapshot

```rust
pub struct MarketSnapshot {
    pub id: String,
    pub question: String,
    pub outcomes: Vec<OutcomeSnapshot>,
    pub volume_24h: Decimal,
    pub status: MarketStatus,
}

pub struct OutcomeSnapshot {
    pub token_id: String,
    pub name: String,
    pub price: Decimal,
    pub bid: Decimal,
    pub ask: Decimal,
}
```

## Signal

Trading signals generated by strategies:

```rust
pub struct Signal {
    pub signal_type: SignalType,
    pub market_id: String,
    pub token_id: String,
    pub size: Decimal,
    pub limit_price: Option<Decimal>,
    pub strength: SignalStrength,
    pub reason: Option<String>,
    pub expiry: Option<Duration>,
}
```

### SignalType

```rust
pub enum SignalType {
    Buy,
    Sell,
}
```

### SignalStrength

```rust
pub enum SignalStrength {
    Weak,
    Medium,
    Strong,
}
```

### Signal Builder

```rust
// Create a buy signal
let signal = Signal::buy("market_id", "token_id", dec!(10.0))
    .with_limit_price(dec!(0.45))
    .with_strength(SignalStrength::Strong)
    .with_reason("Price below fair value")
    .with_expiry(Duration::from_secs(60));

// Create a sell signal
let signal = Signal::sell("market_id", "token_id", dec!(10.0))
    .with_strength(SignalStrength::Medium);
```

## StrategyEngine

Manages strategy lifecycle and execution:

```rust
pub struct StrategyEngine {
    strategies: Vec<StrategyHandle>,
    risk_guard: RiskGuard,
}

impl StrategyEngine {
    /// Create a new engine with risk configuration
    pub fn new(risk_config: RiskConfig) -> Self;
    
    /// Register a strategy
    pub fn register(&mut self, strategy: Box<dyn Strategy>) -> StrategyHandle;
    
    /// Unregister a strategy
    pub fn unregister(&mut self, handle: StrategyHandle);
    
    /// Evaluate all strategies and return validated signals
    pub fn evaluate(&mut self, ctx: &StrategyContext) -> Vec<Signal>;
    
    /// Get status of all strategies
    pub fn status(&self) -> Vec<StrategyStatus>;
}
```

## RiskConfig

Risk management configuration:

```rust
pub struct RiskConfig {
    /// Maximum size for a single position
    pub max_position_size: Decimal,
    /// Maximum total exposure across all positions
    pub max_total_exposure: Decimal,
    /// Maximum position per market
    pub max_position_per_market: Decimal,
    /// Maximum single order size
    pub max_order_size: Decimal,
    /// Maximum number of open orders
    pub max_open_orders: usize,
    /// Maximum daily loss
    pub max_daily_loss: Decimal,
    /// Maximum drawdown percentage
    pub max_drawdown_pct: Decimal,
    /// Minimum order size
    pub min_order_size: Decimal,
    /// Maximum slippage percentage
    pub max_slippage_pct: Decimal,
}
```

## Built-in Strategies

### MomentumStrategy

```rust
let strategy = MomentumStrategy::builder()
    .lookback_periods(10)
    .entry_threshold(dec!(0.05))
    .exit_threshold(dec!(0.02))
    .position_size(dec!(0.10))
    .build();
```

### MeanReversionStrategy

```rust
let strategy = MeanReversionStrategy::builder()
    .window_size(20)
    .entry_z_score(dec!(2.0))
    .exit_z_score(dec!(0.5))
    .position_size(dec!(0.10))
    .build();
```

### SpreadStrategy

```rust
let strategy = SpreadStrategy::builder()
    .min_spread(dec!(0.02))
    .edge(dec!(0.005))
    .order_size(dec!(10.0))
    .max_position(dec!(100.0))
    .build();
```
